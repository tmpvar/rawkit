#version 450
#include "../../svo.h"

#define PI 3.14159265

layout (local_size_x = 8, local_size_y = 8) in;

layout (std430, binding = 0) uniform UBO {
  Scene scene;
} ubo;

layout(std430, binding = 1) readonly buffer NodeTree {
  InnerNode nodes[];
};

layout(std430, binding = 2) readonly buffer NodePositions {
  vec4 node_positions[];
};

layout (binding = 3, rgba32f) uniform writeonly image2D color;

bool ray_aabb(vec3 lb, vec3 ub, vec3 origin, vec3 invDir) {
  bool inside = (
    all(greaterThanEqual(origin, lb)) &&
    all(lessThanEqual(origin, ub))
  );
  vec3 t0 = (lb - origin) * invDir;
  vec3 t1 = (ub - origin) * invDir;
  vec3 tmin = min(t0, t1);
  vec3 tmax = max(t0, t1);
  float m = max(tmin.x, max(tmin.y, tmin.z));
  return inside || (m <= min(tmax.x, min(tmax.y, tmax.z)) && m >= 0.0);
}

void main() {
  vec2 pos = gl_GlobalInvocationID.xy;
  vec2 dims = ubo.scene.screen_dims.xy;

  float aspect = dims.x / dims.y;
  vec2 uv = (pos / dims) * 2.0 - 1.0;
  vec3 dir = (vec4(
    uv.x * ubo.scene.pixel_size * aspect,
    uv.y * ubo.scene.pixel_size,
    -1.0,
    1.0
  ) * ubo.scene.view).xyz;

  vec3 inv_dir = 1.0 / dir;
  vec3 eye = ubo.scene.eye.xyz;

  bool hit = ray_aabb(
    ubo.scene.tree_center - vec3(ubo.scene.tree_radius),
    ubo.scene.tree_center + vec3(ubo.scene.tree_radius),
    ubo.scene.eye.xyz,
    inv_dir
  );

  imageStore(color, ivec2(pos), hit ? vec4(1.0) : vec4(dir * 0.5 + 0.5, 1.0));
}